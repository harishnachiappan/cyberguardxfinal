const { spawn, exec } = require('child_process');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst axios = require('axios');\nconst os = require('os');\n\nclass AutoToolInstaller {\n  constructor() {\n    this.platform = os.platform();\n    this.arch = os.arch();\n    this.toolsDir = path.join(__dirname, '../tools-bin');\n    this.downloadDir = path.join(__dirname, '../downloads');\n    \n    this.toolConfigs = {\n      nmap: {\n        linux: {\n          command: 'sudo apt-get update && sudo apt-get install -y nmap',\n          verify: 'nmap --version'\n        },\n        windows: {\n          url: 'https://nmap.org/dist/nmap-7.94-setup.exe',\n          installer: true\n        }\n      },\n      sqlmap: {\n        linux: {\n          command: 'sudo apt-get install -y sqlmap',\n          verify: 'sqlmap --version'\n        },\n        universal: {\n          url: 'https://github.com/sqlmapproject/sqlmap/archive/master.zip',\n          extract: true,\n          setup: 'python sqlmap.py --version'\n        }\n      },\n      nuclei: {\n        linux: {\n          url: 'https://github.com/projectdiscovery/nuclei/releases/download/v2.9.15/nuclei_2.9.15_linux_amd64.zip',\n          extract: true,\n          binary: 'nuclei'\n        },\n        windows: {\n          url: 'https://github.com/projectdiscovery/nuclei/releases/download/v2.9.15/nuclei_2.9.15_windows_amd64.zip',\n          extract: true,\n          binary: 'nuclei.exe'\n        }\n      },\n      nikto: {\n        linux: {\n          command: 'sudo apt-get install -y nikto',\n          verify: 'nikto -Version'\n        },\n        universal: {\n          url: 'https://github.com/sullo/nikto/archive/master.zip',\n          extract: true,\n          setup: 'perl nikto.pl -Version'\n        }\n      },\n      gobuster: {\n        linux: {\n          command: 'sudo apt-get install -y gobuster',\n          verify: 'gobuster version'\n        },\n        universal: {\n          url: 'https://github.com/OJ/gobuster/releases/download/v3.6.0/gobuster_Linux_x86_64.tar.gz',\n          extract: true,\n          binary: 'gobuster'\n        }\n      },\n      wpscan: {\n        linux: {\n          command: 'sudo gem install wpscan',\n          verify: 'wpscan --version'\n        }\n      },\n      testssl: {\n        universal: {\n          url: 'https://github.com/drwetter/testssl.sh/archive/3.2.zip',\n          extract: true,\n          setup: 'chmod +x testssl.sh'\n        }\n      },\n      zap: {\n        linux: {\n          url: 'https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2_14_0_unix.sh',\n          installer: true,\n          setup: 'chmod +x ZAP_2_14_0_unix.sh && ./ZAP_2_14_0_unix.sh -q'\n        },\n        windows: {\n          url: 'https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2_14_0_windows.exe',\n          installer: true\n        }\n      }\n    };\n  }\n\n  async ensureDirectories() {\n    await fs.ensureDir(this.toolsDir);\n    await fs.ensureDir(this.downloadDir);\n  }\n\n  async installAllTools() {\n    await this.ensureDirectories();\n    \n    const results = {\n      success: [],\n      failed: [],\n      skipped: []\n    };\n\n    console.log('ğŸš€ Starting automated tool installation...');\n\n    for (const [toolName, config] of Object.entries(this.toolConfigs)) {\n      try {\n        console.log(`ğŸ“¦ Installing ${toolName}...`);\n        \n        // Check if tool already exists\n        if (await this.isToolInstalled(toolName)) {\n          console.log(`âœ… ${toolName} already installed, skipping`);\n          results.skipped.push(toolName);\n          continue;\n        }\n\n        const installed = await this.installTool(toolName, config);\n        if (installed) {\n          results.success.push(toolName);\n          console.log(`âœ… ${toolName} installed successfully`);\n        } else {\n          results.failed.push(toolName);\n          console.log(`âŒ ${toolName} installation failed`);\n        }\n      } catch (error) {\n        console.error(`âŒ Error installing ${toolName}:`, error.message);\n        results.failed.push(toolName);\n      }\n    }\n\n    // Install wordlists\n    try {\n      await this.installWordlists();\n      console.log('âœ… Wordlists installed');\n    } catch (error) {\n      console.error('âŒ Wordlists installation failed:', error.message);\n    }\n\n    console.log('ğŸ‰ Tool installation completed!');\n    console.log(`âœ… Success: ${results.success.length}`);\n    console.log(`âŒ Failed: ${results.failed.length}`);\n    console.log(`â­ï¸ Skipped: ${results.skipped.length}`);\n\n    return results;\n  }\n\n  async installTool(toolName, config) {\n    try {\n      // Try platform-specific installation first\n      const platformConfig = config[this.platform] || config.universal;\n      \n      if (!platformConfig) {\n        console.log(`âš ï¸ No installation method for ${toolName} on ${this.platform}`);\n        return false;\n      }\n\n      // Method 1: Package manager installation\n      if (platformConfig.command) {\n        return await this.installViaCommand(toolName, platformConfig);\n      }\n\n      // Method 2: Download and install\n      if (platformConfig.url) {\n        return await this.installViaDownload(toolName, platformConfig);\n      }\n\n      return false;\n    } catch (error) {\n      console.error(`Installation error for ${toolName}:`, error);\n      return false;\n    }\n  }\n\n  async installViaCommand(toolName, config) {\n    try {\n      console.log(`ğŸ”§ Installing ${toolName} via package manager...`);\n      \n      await this.executeCommand(config.command, { shell: true });\n      \n      // Verify installation\n      if (config.verify) {\n        await this.executeCommand(config.verify, { shell: true });\n      }\n      \n      return true;\n    } catch (error) {\n      console.error(`Package manager installation failed for ${toolName}:`, error.message);\n      return false;\n    }\n  }\n\n  async installViaDownload(toolName, config) {\n    try {\n      console.log(`ğŸ“¥ Downloading ${toolName}...`);\n      \n      const filename = path.basename(config.url);\n      const downloadPath = path.join(this.downloadDir, filename);\n      const toolPath = path.join(this.toolsDir, toolName);\n      \n      // Download file\n      await this.downloadFile(config.url, downloadPath);\n      \n      // Create tool directory\n      await fs.ensureDir(toolPath);\n      \n      // Handle different file types\n      if (config.extract) {\n        await this.extractFile(downloadPath, toolPath);\n      } else if (config.installer) {\n        // For installer files, just make executable\n        if (this.platform !== 'win32') {\n          await this.executeCommand(`chmod +x \"${downloadPath}\"`);\n        }\n        // Copy to tools directory\n        await fs.copy(downloadPath, path.join(toolPath, filename));\n      } else {\n        // Copy binary file\n        await fs.copy(downloadPath, path.join(toolPath, config.binary || toolName));\n      }\n      \n      // Run setup commands\n      if (config.setup) {\n        await this.executeCommand(config.setup, { cwd: toolPath, shell: true });\n      }\n      \n      // Make binary executable\n      if (config.binary && this.platform !== 'win32') {\n        const binaryPath = path.join(toolPath, config.binary);\n        if (await fs.pathExists(binaryPath)) {\n          await this.executeCommand(`chmod +x \"${binaryPath}\"`);\n        }\n      }\n      \n      // Add to PATH (create symlink)\n      await this.addToPath(toolName, toolPath, config.binary);\n      \n      return true;\n    } catch (error) {\n      console.error(`Download installation failed for ${toolName}:`, error.message);\n      return false;\n    }\n  }\n\n  async downloadFile(url, outputPath) {\n    const response = await axios({\n      method: 'GET',\n      url: url,\n      responseType: 'stream',\n      timeout: 300000 // 5 minutes\n    });\n\n    const writer = fs.createWriteStream(outputPath);\n    response.data.pipe(writer);\n\n    return new Promise((resolve, reject) => {\n      writer.on('finish', resolve);\n      writer.on('error', reject);\n    });\n  }\n\n  async extractFile(archivePath, extractPath) {\n    const ext = path.extname(archivePath).toLowerCase();\n    \n    try {\n      if (ext === '.zip') {\n        await this.executeCommand(`unzip -q \"${archivePath}\" -d \"${extractPath}\"`);\n      } else if (ext === '.gz' || ext === '.tar') {\n        await this.executeCommand(`tar -xzf \"${archivePath}\" -C \"${extractPath}\"`);\n      } else {\n        throw new Error(`Unsupported archive format: ${ext}`);\n      }\n    } catch (error) {\n      // Fallback: try with node modules if available\n      console.log(`âš ï¸ System extraction failed, trying alternative method...`);\n      throw error;\n    }\n  }\n\n  async addToPath(toolName, toolPath, binary) {\n    try {\n      const binDir = '/usr/local/bin';\n      const binaryName = binary || toolName;\n      const sourcePath = path.join(toolPath, binaryName);\n      const linkPath = path.join(binDir, toolName);\n      \n      if (await fs.pathExists(sourcePath)) {\n        // Create symlink\n        if (this.platform !== 'win32') {\n          await this.executeCommand(`sudo ln -sf \"${sourcePath}\" \"${linkPath}\"`);\n        }\n      }\n    } catch (error) {\n      console.log(`âš ï¸ Could not add ${toolName} to PATH:`, error.message);\n    }\n  }\n\n  async installWordlists() {\n    console.log('ğŸ“š Installing wordlists...');\n    \n    const wordlistsPath = path.join(this.toolsDir, 'wordlists');\n    await fs.ensureDir(wordlistsPath);\n    \n    // Install SecLists\n    try {\n      const secListsPath = path.join(wordlistsPath, 'SecLists');\n      if (!(await fs.pathExists(secListsPath))) {\n        await this.executeCommand(\n          `git clone https://github.com/danielmiessler/SecLists.git \"${secListsPath}\"`,\n          { timeout: 300000 }\n        );\n      }\n    } catch (error) {\n      console.log('âš ï¸ SecLists installation failed:', error.message);\n    }\n    \n    // Install common wordlists via package manager\n    try {\n      if (this.platform === 'linux') {\n        await this.executeCommand('sudo apt-get install -y dirb wordlists');\n      }\n    } catch (error) {\n      console.log('âš ï¸ System wordlists installation failed:', error.message);\n    }\n  }\n\n  async isToolInstalled(toolName) {\n    try {\n      await this.executeCommand(`which ${toolName}`, { timeout: 5000 });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async executeCommand(command, options = {}) {\n    return new Promise((resolve, reject) => {\n      const process = spawn('bash', ['-c', command], {\n        stdio: ['pipe', 'pipe', 'pipe'],\n        ...options\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      process.stdout.on('data', (data) => {\n        stdout += data.toString();\n      });\n\n      process.stderr.on('data', (data) => {\n        stderr += data.toString();\n      });\n\n      const timeout = setTimeout(() => {\n        process.kill('SIGTERM');\n        reject(new Error('Command timeout'));\n      }, options.timeout || 60000);\n\n      process.on('close', (code) => {\n        clearTimeout(timeout);\n        if (code === 0) {\n          resolve({ stdout, stderr, code });\n        } else {\n          reject(new Error(`Command failed with code ${code}: ${stderr}`));\n        }\n      });\n\n      process.on('error', (error) => {\n        clearTimeout(timeout);\n        reject(error);\n      });\n    });\n  }\n\n  // Docker-based installation as fallback\n  async installViaDocker() {\n    console.log('ğŸ³ Setting up Docker-based tools...');\n    \n    const dockerCommands = [\n      'docker pull owasp/zap2docker-stable',\n      'docker pull sonarqube:community',\n      'docker pull projectdiscovery/nuclei',\n      'docker pull paoloo/sqlmap'\n    ];\n    \n    for (const command of dockerCommands) {\n      try {\n        await this.executeCommand(command, { timeout: 600000 }); // 10 minutes\n        console.log(`âœ… ${command} completed`);\n      } catch (error) {\n        console.log(`âš ï¸ ${command} failed:`, error.message);\n      }\n    }\n  }\n\n  // Generate installation script\n  generateInstallScript() {\n    const script = `#!/bin/bash\n# CyberGuardX Auto-Installer Script\n\necho \"ğŸš€ CyberGuardX Security Tools Auto-Installer\"\necho \"===========================================\"\n\n# Update system\necho \"ğŸ“¦ Updating system packages...\"\nsudo apt-get update\n\n# Install basic tools\necho \"ğŸ”§ Installing basic security tools...\"\nsudo apt-get install -y nmap sqlmap nikto dirb gobuster curl wget git unzip\n\n# Install Ruby for WPScan\necho \"ğŸ’ Installing Ruby and WPScan...\"\nsudo apt-get install -y ruby ruby-dev\nsudo gem install wpscan\n\n# Install Go and Nuclei\necho \"ğŸ”µ Installing Go and Nuclei...\"\nwget https://golang.org/dl/go1.21.0.linux-amd64.tar.gz\nsudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz\nexport PATH=$PATH:/usr/local/go/bin\ngo install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest\n\n# Install testssl.sh\necho \"ğŸ”’ Installing testssl.sh...\"\ngit clone https://github.com/drwetter/testssl.sh.git /opt/testssl\nsudo ln -sf /opt/testssl/testssl.sh /usr/local/bin/testssl.sh\n\n# Install wordlists\necho \"ğŸ“š Installing wordlists...\"\ngit clone https://github.com/danielmiessler/SecLists.git /opt/SecLists\nsudo apt-get install -y wordlists\n\n# Docker setup (optional)\necho \"ğŸ³ Setting up Docker tools (optional)...\"\ndocker pull owasp/zap2docker-stable\ndocker pull sonarqube:community\ndocker pull projectdiscovery/nuclei\n\necho \"âœ… Installation completed!\"\necho \"ğŸ‰ CyberGuardX tools are ready to use!\"\n`;\n    \n    return script;\n  }\n}\n\nmodule.exports = AutoToolInstaller;