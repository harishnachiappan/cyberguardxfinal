const { GoogleGenerativeAI } = require('@google/generative-ai');\nconst axios = require('axios');\n\nclass MultiAIProvider {\n  constructor() {\n    // Initialize multiple AI providers\n    this.providers = {\n      gemini: this.initGemini(),\n      huggingface: this.initHuggingFace(),\n      ollama: this.initOllama(),\n      fallback: this.initFallback()\n    };\n    \n    this.currentProvider = 'gemini'; // Default to Gemini\n  }\n\n  initGemini() {\n    if (process.env.GEMINI_API_KEY && process.env.GEMINI_API_KEY !== 'demo-key') {\n      const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);\n      return {\n        model: genAI.getGenerativeModel({ model: 'gemini-pro' }),\n        available: true,\n        name: 'Google Gemini Pro',\n        cost: 'Free (15 RPM, 1500/day)'\n      };\n    }\n    return { available: false };\n  }\n\n  initHuggingFace() {\n    // Hugging Face Inference API (FREE)\n    return {\n      available: true,\n      name: 'Hugging Face (Free)',\n      cost: 'Completely Free',\n      endpoint: 'https://api-inference.huggingface.co/models/microsoft/DialoGPT-medium'\n    };\n  }\n\n  initOllama() {\n    // Local Ollama (FREE - runs locally)\n    return {\n      available: true,\n      name: 'Ollama (Local)',\n      cost: 'Free (Local)',\n      endpoint: 'http://localhost:11434/api/generate'\n    };\n  }\n\n  initFallback() {\n    // Rule-based fallback (always available)\n    return {\n      available: true,\n      name: 'Rule-based Analysis',\n      cost: 'Free (No API)'\n    };\n  }\n\n  async generateResponse(prompt, context = {}) {\n    const providers = ['gemini', 'huggingface', 'ollama', 'fallback'];\n    \n    for (const providerName of providers) {\n      const provider = this.providers[providerName];\n      if (!provider.available) continue;\n      \n      try {\n        console.log(`ü§ñ Trying ${provider.name}...`);\n        const response = await this.callProvider(providerName, prompt, context);\n        if (response) {\n          console.log(`‚úÖ Success with ${provider.name}`);\n          return {\n            response,\n            provider: provider.name,\n            cost: provider.cost\n          };\n        }\n      } catch (error) {\n        console.log(`‚ùå ${provider.name} failed:`, error.message);\n        continue;\n      }\n    }\n    \n    // If all fail, return basic response\n    return {\n      response: \"I'm having trouble with AI services right now, but I can help with basic vulnerability scanning guidance.\",\n      provider: 'Fallback',\n      cost: 'Free'\n    };\n  }\n\n  async callProvider(providerName, prompt, context) {\n    switch (providerName) {\n      case 'gemini':\n        return await this.callGemini(prompt);\n      case 'huggingface':\n        return await this.callHuggingFace(prompt);\n      case 'ollama':\n        return await this.callOllama(prompt);\n      case 'fallback':\n        return this.callFallback(prompt, context);\n      default:\n        throw new Error('Unknown provider');\n    }\n  }\n\n  async callGemini(prompt) {\n    const provider = this.providers.gemini;\n    if (!provider.available) throw new Error('Gemini not available');\n    \n    const result = await provider.model.generateContent(prompt);\n    return result.response.text();\n  }\n\n  async callHuggingFace(prompt) {\n    // Free Hugging Face API\n    const response = await axios.post(\n      'https://api-inference.huggingface.co/models/microsoft/DialoGPT-medium',\n      { inputs: prompt },\n      {\n        headers: {\n          'Authorization': `Bearer ${process.env.HUGGINGFACE_API_KEY || 'hf_demo'}`,\n          'Content-Type': 'application/json'\n        },\n        timeout: 10000\n      }\n    );\n    \n    return response.data.generated_text || response.data[0]?.generated_text;\n  }\n\n  async callOllama(prompt) {\n    // Local Ollama (completely free)\n    try {\n      const response = await axios.post('http://localhost:11434/api/generate', {\n        model: 'llama2',\n        prompt: prompt,\n        stream: false\n      }, { timeout: 15000 });\n      \n      return response.data.response;\n    } catch (error) {\n      throw new Error('Ollama not running locally');\n    }\n  }\n\n  callFallback(prompt, context) {\n    // Rule-based responses for cybersecurity\n    const lowerPrompt = prompt.toLowerCase();\n    \n    if (lowerPrompt.includes('sql injection')) {\n      return \"SQL injection is a critical vulnerability. I recommend testing login forms, search fields, and URL parameters with payloads like ' OR '1'='1. Use parameterized queries to prevent this.\";\n    }\n    \n    if (lowerPrompt.includes('xss')) {\n      return \"Cross-Site Scripting (XSS) allows attackers to inject malicious scripts. Test input fields with <script>alert('XSS')</script>. Implement proper input validation and output encoding.\";\n    }\n    \n    if (lowerPrompt.includes('csrf')) {\n      return \"CSRF attacks trick users into performing unwanted actions. Check if forms have CSRF tokens. Implement anti-CSRF tokens and SameSite cookies.\";\n    }\n    \n    if (lowerPrompt.includes('scan') || lowerPrompt.includes('vulnerability')) {\n      return \"For comprehensive security testing, start with high-priority vulnerabilities like SQL injection and XSS. Then proceed to access control and CSRF testing. Each scan typically takes 5-10 minutes.\";\n    }\n    \n    if (lowerPrompt.includes('priority') || lowerPrompt.includes('order')) {\n      return \"Recommended scan order: 1) SQL Injection (High priority), 2) XSS (High priority), 3) Access Control (High priority), 4) CSRF (Medium priority), 5) Security Headers (Low priority).\";\n    }\n    \n    return \"I can help you with vulnerability scanning. Ask me about SQL injection, XSS, CSRF, or which scans to prioritize for your target.\";\n  }\n\n  getAvailableProviders() {\n    return Object.entries(this.providers)\n      .filter(([name, provider]) => provider.available)\n      .map(([name, provider]) => ({\n        name,\n        displayName: provider.name,\n        cost: provider.cost\n      }));\n  }\n}\n\nmodule.exports = MultiAIProvider;