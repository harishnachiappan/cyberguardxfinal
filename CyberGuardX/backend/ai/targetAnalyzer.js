const axios = require('axios');
const cheerio = require('cheerio');
const dns = require('dns').promises;
const whois = require('whois');
const geoip = require('geoip-lite');
const sslChecker = require('ssl-checker');

class AITargetAnalyzer {
  constructor() {
    // Using multiple free AI services as fallbacks
    this.freeAIServices = [
      {
        name: 'Hugging Face',
        endpoint: 'https://api-inference.huggingface.co/models/microsoft/DialoGPT-medium',
        headers: { 'Authorization': `Bearer ${process.env.HUGGINGFACE_API_KEY || 'hf_demo'}` }
      },
      {
        name: 'Cohere Free',
        endpoint: 'https://api.cohere.ai/v1/generate',
        headers: { 'Authorization': `Bearer ${process.env.COHERE_API_KEY || 'demo'}` }
      },
      {
        name: 'Local AI (Offline)',
        endpoint: 'local',
        headers: {}
      }
    ];
  }

  async analyzeTarget(targetUrl) {
    try {
      console.log(`ðŸ¤– AI analyzing target: ${targetUrl}`);\n      
      // Step 1: Gather technical information
      const techInfo = await this.gatherTechnicalInfo(targetUrl);
      
      // Step 2: AI-powered analysis
      const aiAnalysis = await this.performAIAnalysis(targetUrl, techInfo);
      
      // Step 3: Generate vulnerability recommendations
      const recommendations = await this.generateVulnerabilityRecommendations(techInfo, aiAnalysis);
      
      return {\n        targetInfo: techInfo,\n        aiAnalysis,\n        recommendations,\n        chatContext: this.initializeChatContext(targetUrl, techInfo)\n      };\n    } catch (error) {\n      console.error('AI Analysis Error:', error);\n      return this.getFallbackAnalysis(targetUrl);\n    }\n  }\n\n  async gatherTechnicalInfo(targetUrl) {\n    const info = {\n      url: targetUrl,\n      domain: new URL(targetUrl).hostname,\n      timestamp: new Date().toISOString()\n    };\n\n    try {\n      // DNS Resolution\n      const dnsInfo = await dns.lookup(info.domain);\n      info.ip = dnsInfo.address;\n      info.family = dnsInfo.family;\n\n      // Geolocation\n      const geo = geoip.lookup(info.ip);\n      info.location = geo ? {\n        country: geo.country,\n        region: geo.region,\n        city: geo.city,\n        timezone: geo.timezone\n      } : null;\n\n      // SSL Certificate Check\n      if (targetUrl.startsWith('https')) {\n        try {\n          const sslInfo = await sslChecker(info.domain);\n          info.ssl = {\n            valid: sslInfo.valid,\n            validFrom: sslInfo.validFrom,\n            validTo: sslInfo.validTo,\n            issuer: sslInfo.issuer\n          };\n        } catch (sslError) {\n          info.ssl = { valid: false, error: sslError.message };\n        }\n      }\n\n      // HTTP Response Analysis\n      const response = await axios.get(targetUrl, {\n        timeout: 10000,\n        maxRedirects: 5,\n        validateStatus: () => true\n      });\n\n      info.httpStatus = response.status;\n      info.headers = response.headers;\n      info.responseTime = response.headers['x-response-time'] || 'N/A';\n      \n      // Technology Detection\n      info.technologies = this.detectTechnologies(response.headers, response.data);\n      \n      // Security Headers Analysis\n      info.securityHeaders = this.analyzeSecurityHeaders(response.headers);\n      \n      // Content Analysis\n      const $ = cheerio.load(response.data);\n      info.pageInfo = {\n        title: $('title').text(),\n        forms: $('form').length,\n        inputs: $('input').length,\n        links: $('a').length,\n        scripts: $('script').length,\n        hasLogin: this.detectLoginForms($)\n      };\n\n    } catch (error) {\n      console.error('Technical info gathering error:', error);\n      info.error = error.message;\n    }\n\n    return info;\n  }\n\n  detectTechnologies(headers, html) {\n    const technologies = [];\n    \n    // Server detection\n    if (headers.server) {\n      technologies.push({ name: headers.server, category: 'Web Server' });\n    }\n    \n    // Framework detection\n    if (headers['x-powered-by']) {\n      technologies.push({ name: headers['x-powered-by'], category: 'Framework' });\n    }\n    \n    // Content-based detection\n    if (html.includes('react')) technologies.push({ name: 'React', category: 'Frontend' });\n    if (html.includes('angular')) technologies.push({ name: 'Angular', category: 'Frontend' });\n    if (html.includes('vue')) technologies.push({ name: 'Vue.js', category: 'Frontend' });\n    if (html.includes('jquery')) technologies.push({ name: 'jQuery', category: 'Library' });\n    if (html.includes('bootstrap')) technologies.push({ name: 'Bootstrap', category: 'CSS Framework' });\n    \n    return technologies;\n  }\n\n  analyzeSecurityHeaders(headers) {\n    return {\n      'Content-Security-Policy': headers['content-security-policy'] ? 'Present' : 'Missing',\n      'X-Frame-Options': headers['x-frame-options'] ? 'Present' : 'Missing',\n      'X-XSS-Protection': headers['x-xss-protection'] ? 'Present' : 'Missing',\n      'X-Content-Type-Options': headers['x-content-type-options'] ? 'Present' : 'Missing',\n      'Strict-Transport-Security': headers['strict-transport-security'] ? 'Present' : 'Missing'\n    };\n  }\n\n  detectLoginForms($) {\n    const loginIndicators = ['login', 'signin', 'password', 'username', 'email'];\n    let hasLogin = false;\n    \n    $('form').each((i, form) => {\n      const formHtml = $(form).html().toLowerCase();\n      if (loginIndicators.some(indicator => formHtml.includes(indicator))) {\n        hasLogin = true;\n      }\n    });\n    \n    return hasLogin;\n  }\n\n  async performAIAnalysis(targetUrl, techInfo) {\n    try {\n      const prompt = `\nAs a cybersecurity expert, analyze this web application:\n\nTarget: ${targetUrl}\nTechnologies: ${JSON.stringify(techInfo.technologies)}\nSecurity Headers: ${JSON.stringify(techInfo.securityHeaders)}\nSSL Info: ${JSON.stringify(techInfo.ssl)}\nPage Info: ${JSON.stringify(techInfo.pageInfo)}\n\nProvide a brief security assessment focusing on:\n1. Potential attack vectors\n2. Technology-specific vulnerabilities\n3. Missing security controls\n4. Risk level (Low/Medium/High)\n\nKeep response under 200 words and be specific.\n`;\n\n      const result = await this.model.generateContent(prompt);\n      return result.response.text();\n    } catch (error) {\n      return this.getFallbackAIAnalysis(techInfo);\n    }\n  }\n\n  async generateVulnerabilityRecommendations(techInfo, aiAnalysis) {\n    const recommendations = [];\n    \n    // Rule-based recommendations with AI enhancement\n    const vulnMap = {\n      'sql-injection': {\n        priority: 'High',\n        reason: 'Database interactions detected',\n        tools: ['sqlmap', 'custom-sql-scanner']\n      },\n      'xss': {\n        priority: 'High', \n        reason: 'User input forms detected',\n        tools: ['xssstrike', 'custom-xss-scanner']\n      },\n      'csrf': {\n        priority: 'Medium',\n        reason: 'Forms without CSRF protection',\n        tools: ['custom-csrf-scanner']\n      },\n      'access-control': {\n        priority: 'High',\n        reason: 'Authentication mechanisms present',\n        tools: ['custom-auth-scanner']\n      }\n    };\n\n    // Smart recommendations based on tech stack\n    if (techInfo.pageInfo?.hasLogin) {\n      recommendations.push({\n        id: 'sql-injection',\n        name: 'SQL Injection Scanner',\n        category: 'OWASP A03',\n        priority: 'High',\n        reason: 'Login forms detected - high SQL injection risk',\n        estimatedTime: '5-10 minutes',\n        tools: vulnMap['sql-injection'].tools\n      });\n      \n      recommendations.push({\n        id: 'access-control',\n        name: 'Access Control Scanner', \n        category: 'OWASP A01',\n        priority: 'High',\n        reason: 'Authentication system requires access control testing',\n        estimatedTime: '3-7 minutes',\n        tools: vulnMap['access-control'].tools\n      });\n    }\n\n    if (techInfo.pageInfo?.forms > 0) {\n      recommendations.push({\n        id: 'xss',\n        name: 'Cross-Site Scripting Scanner',\n        category: 'OWASP A03', \n        priority: 'High',\n        reason: `${techInfo.pageInfo.forms} forms detected - XSS vulnerability risk`,\n        estimatedTime: '4-8 minutes',\n        tools: vulnMap['xss'].tools\n      });\n      \n      recommendations.push({\n        id: 'csrf',\n        name: 'CSRF Protection Scanner',\n        category: 'OWASP A01',\n        priority: 'Medium',\n        reason: 'Forms require CSRF token validation',\n        estimatedTime: '2-5 minutes', \n        tools: vulnMap['csrf'].tools\n      });\n    }\n\n    // Security headers analysis\n    const missingHeaders = Object.entries(techInfo.securityHeaders || {})\n      .filter(([key, value]) => value === 'Missing').length;\n    \n    if (missingHeaders > 2) {\n      recommendations.push({\n        id: 'security-headers',\n        name: 'Security Headers Scanner',\n        category: 'Security Configuration',\n        priority: 'Medium',\n        reason: `${missingHeaders} critical security headers missing`,\n        estimatedTime: '1-3 minutes',\n        tools: ['custom-header-scanner']\n      });\n    }\n\n    // SSL/TLS analysis\n    if (!techInfo.ssl?.valid) {\n      recommendations.push({\n        id: 'ssl-tls',\n        name: 'SSL/TLS Security Scanner',\n        category: 'Cryptographic Failures',\n        priority: 'High',\n        reason: 'SSL certificate issues detected',\n        estimatedTime: '2-4 minutes',\n        tools: ['sslscan', 'testssl']\n      });\n    }\n\n    return recommendations.slice(0, 6); // Limit to top 6 recommendations\n  }\n\n  initializeChatContext(targetUrl, techInfo) {\n    return {\n      targetUrl,\n      conversationHistory: [],\n      context: {\n        technologies: techInfo.technologies,\n        securityHeaders: techInfo.securityHeaders,\n        hasLogin: techInfo.pageInfo?.hasLogin,\n        formCount: techInfo.pageInfo?.forms\n      },\n      suggestions: [\n        \"What vulnerabilities should I prioritize?\",\n        \"Explain the recommended scan sequence\",\n        \"What tools will be used for scanning?\",\n        \"How long will the complete scan take?\"\n      ]\n    };\n  }\n\n  async chatWithAI(message, context) {\n    try {\n      const prompt = `\nYou are a cybersecurity assistant helping with vulnerability scanning of ${context.targetUrl}.\n\nContext:\n- Technologies: ${JSON.stringify(context.context.technologies)}\n- Security Headers: ${JSON.stringify(context.context.securityHeaders)}\n- Has Login: ${context.context.hasLogin}\n- Form Count: ${context.context.formCount}\n\nConversation History:\n${context.conversationHistory.map(h => `${h.role}: ${h.message}`).join('\\n')}\n\nUser Question: ${message}\n\nProvide a helpful, specific response about vulnerability scanning. Keep it under 150 words.\n`;\n\n      const result = await this.model.generateContent(prompt);\n      const response = result.response.text();\n      \n      // Update conversation history\n      context.conversationHistory.push(\n        { role: 'user', message, timestamp: new Date() },\n        { role: 'assistant', message: response, timestamp: new Date() }\n      );\n      \n      return {\n        response,\n        context,\n        suggestions: this.generateFollowUpSuggestions(message, response)\n      };\n    } catch (error) {\n      return {\n        response: \"I'm having trouble connecting to the AI service. However, I can help you with the vulnerability scanning process. What specific aspect would you like to know about?\",\n        context,\n        suggestions: context.suggestions\n      };\n    }\n  }\n\n  generateFollowUpSuggestions(userMessage, aiResponse) {\n    const suggestions = [\n      \"Start the recommended scans\",\n      \"Explain scan methodology\", \n      \"Show expected results\",\n      \"Security best practices\"\n    ];\n    \n    if (userMessage.toLowerCase().includes('tool')) {\n      suggestions.unshift(\"What tools are most effective?\");\n    }\n    \n    if (userMessage.toLowerCase().includes('time')) {\n      suggestions.unshift(\"How to optimize scan time?\");\n    }\n    \n    return suggestions.slice(0, 4);\n  }\n\n  getFallbackAnalysis(targetUrl) {\n    return {\n      targetInfo: {\n        url: targetUrl,\n        domain: new URL(targetUrl).hostname,\n        error: 'Limited analysis mode'\n      },\n      aiAnalysis: 'AI analysis temporarily unavailable. Proceeding with standard vulnerability assessment.',\n      recommendations: this.getDefaultRecommendations(),\n      chatContext: {\n        targetUrl,\n        conversationHistory: [],\n        context: { fallbackMode: true },\n        suggestions: [\"Start basic vulnerability scan\", \"View scan modules\", \"Check scan status\"]\n      }\n    };\n  }\n\n  getFallbackAIAnalysis(techInfo) {\n    let analysis = \"Security Assessment: \";\n    \n    if (techInfo.pageInfo?.hasLogin) {\n      analysis += \"Authentication system detected - recommend SQL injection and access control testing. \";\n    }\n    \n    if (techInfo.pageInfo?.forms > 0) {\n      analysis += `${techInfo.pageInfo.forms} forms found - XSS and CSRF testing recommended. `;\n    }\n    \n    const missingHeaders = Object.values(techInfo.securityHeaders || {}).filter(v => v === 'Missing').length;\n    if (missingHeaders > 0) {\n      analysis += `${missingHeaders} security headers missing - configuration review needed.`;\n    }\n    \n    return analysis || \"Standard vulnerability assessment recommended.\";\n  }\n\n  getDefaultRecommendations() {\n    return [\n      {\n        id: 'sql-injection',\n        name: 'SQL Injection Scanner',\n        category: 'OWASP A03',\n        priority: 'High',\n        reason: 'Standard security assessment',\n        estimatedTime: '5-10 minutes',\n        tools: ['sqlmap']\n      },\n      {\n        id: 'xss',\n        name: 'Cross-Site Scripting Scanner', \n        category: 'OWASP A03',\n        priority: 'High',\n        reason: 'Standard security assessment',\n        estimatedTime: '4-8 minutes',\n        tools: ['xssstrike']\n      }\n    ];\n  }\n}\n\nmodule.exports = AITargetAnalyzer;